#!/usr/bin/env python

#######################
# Author: B. Anderson
# Date: Mar 2021
# Modified: Apr 2021 (no longer alternative search files)
# Description: remove duplicate entries from an ncbi search summary file (generated by ncbi_search.py)
#######################


import sys


# create a help function for when the script fails or is called without arguments
def help():
	print('')
	print('This script will remove duplicate entries from an ncbi search summary file (arg1)')
	print('')
	print('Usage: ' + str(sys.argv[0]) + ' search_summary')
	print('')
	print('')


# check command arguments
if len(sys.argv) != 2:
	sys.exit(help())
else:
	search_file = sys.argv[1]


# open and parse the search file
with open(search_file, 'r') as input:
	search_type = 0
	capture_list = []
	for lineno, line in enumerate(input, start = 1):
		if lineno == 1:
#			if line.split('\t')[0] == 'genus':		# for when no taxonomy option has been used
#				search_type = 1
#			elif line.split('\t')[0] == 'order':		# with the taxonomy option
#				search_type = 2
			if line.split('\t')[0] == 'order':
				continue
			else:
				sys.exit('Improper header line. Contents of the search summary are questionable.')
		else:
			# capture the line elements into a list
			elements = line.rstrip().split('\t')
			capture_list.append(elements)


# add all the NC_ accessions to final list
final_list = []
for element in capture_list:
#	if search_type == 1:
#		if element[2].startswith('NC_'):
#			final_list.append(element)
#	elif search_type == 2:
#		if element[4].startswith('NC_'):
#			final_list.append(element)
	if element[4].startswith('NC_'):
		final_list.append(element)
#	else:
#		sys.exit('Something went wrong!')


# add the remainder if they aren't the same
for element in capture_list:
	if element in final_list:
		continue
	else:
		found = False
		for entry in final_list:
#			if search_type == 1:
#				if all([element[0] == entry[0], element[1] == entry[1], element[3] == entry[3], element[4] == entry[4]]):
#					found = True
#					break
#			elif search_type == 2:
			# if the names and length are the same, but accession differs, then a duplicate
			if all([element[2] == entry[2], element[3] == entry[3], element[5] == entry[5]]):
				found = True
				break
#			else:
#				sys.exit('Something went wrong!')

		if not found:
			final_list.append(element)


# sort the list and output to file
with open(search_file.rsplit('.', 1)[0] + '_nodups.tab', 'w') as output:
#	if search_type == 1:
#		output.write('\t'.join(['genus', 'specific_ep', 'accession', 'length', 'full_title']) + '\n')
#	else:
	output.write('\t'.join(['order', 'family', 'genus', 'specific_ep', 'accession', 'length', 'full_title']) + '\n')
	final_list.sort()
	for entry in final_list:
		output.write('\t'.join(entry) + '\n')
